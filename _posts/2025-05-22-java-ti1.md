---
title: "[Java] 백엔드 Interview 1"
excerpt: "Java, Spring, DB, CS"

categories:
  - Java
tags:
  - [java, 기술면접]

permalink: /java/ti1/

toc: true
toc_sticky: true

date: 2025-05-23
last_modified_at: 2025-05-23
---

## 객체지향 프로그래밍

프로그램 구현에 필요한 객체를 파악, 역할을 정의하여 만들고 객체들간의 상호작용을 통해 프로그램을 만드는 것

## 절차지향 프로그래밍

프로그램의 순서와 흐름을 먼저 세우고 필요한 자료구조와 함수를 설계하는 방식

하나의 큰 기능을 위해 작은 기능들로 나누어 처리하는 top-down 방식이며, 여러 함수가 데이터를 공유한다.

유지보수가 어렵고 재사용성이 낮으며, 보안 개념이 약하다.

## 객체지향 / 함수형 차이

| 항목                      | 객체지향 프로그래밍 (OOP)             | 함수형 프로그래밍 (FP)                              |
| ----------------------- | ---------------------------- | ------------------------------------------- |
| **설계 방식**               | **객체 중심의 설계**                | **함수 중심의 설계**                               |
| **코드 구조**               | 객체들 간의 **관계와 메시지 전달** 중심     | **함수 조합과 데이터 흐름** 중심                        |
| **주요 단위**               | 객체(클래스 기반)                   | 함수(값처럼 취급되는 연산 단위)                          |
| **일급 객체**               | 클래스 또는 객체                    | 함수 자체가 일급 객체                                |
| **상태 변화**               | 객체 내부 상태를 바꿀 수 있음            | 상태 변화 지양, 불변성 추구                            |
| **입력 → 출력**             | 같은 입력이어도 **상태에 따라 다른 결과** 가능 | 같은 입력이면 **항상 같은 출력** (순수 함수)                |

## 객체지향 프로그래밍의 장단점

**장점**
- 코드의 확장성과 재사용성이 좋다.
- 유지보수가 용이하다.
- 메서드로 접근하기 때문에 보안성이 좋다.

**단점**
- 메모리 비용이 큼
- 캡슐화, 격리구조로 인해 실행속도가 절차지향 프로그래밍에 비해 느림

## 객체지향 프로그래밍 4가지 특징

**추상화**
필요한 정보만을 중심으로 구현

**캡슐화**
객체가 독립적인 역할을 할 수 있도록 데이터와 기능을 묶어 관리한다.

실제 구현되는 부분을 외부에 드러나지 않도록 은닉화가 가능하다.

**상속성**
다른 클래스의 기능을 물려받아 사용할 수 있다.

기존 코드를 재사용해 확장이 가능하다.

**다형성**
하나의 클래스나 메서드가 다양한 방식으로 동작이 가능한 것을 말한다.

오버라이딩: 자식 클래스에서 부모 클래스의 기능을 재정의 하는 것
오버로딩: 메서드명은 동일하지만 파라미터 타입, 수를 다르게 하여 재사용하는 것

## 객체지향 설계원칙 5가지 (SOLID)

**단일 책임 원칙 (Single responsibility principle)**
한 클래스는 하나의 책임만을 가진다.

클래스가 여러 기능을 갖게 될 경우 변경 사유가 많아지며, 변경할 경우 다른 기능에 영향을 끼친다.

**개방-폐쇄 원칙 (Open/closed principle)**
소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려있어야 하고, 변경에 대해서는 닫혀있어야 한다.

새로운 기능을 추가할 경우, 수정이 아니라 확장할 것

**리스코프 치환 원칙 (Liskov substitution principle)**
자식 클래스가 부모 클래스를 대체할 수 있어야 한다.

**인터페이스 분리 원칙 (Interface segregation principle)**
클라이언트가 사용하지 않는 메서드에 의존하지 않아야 한다.

큰덩어리의 인터페이스를 구체적이고 작은 단위로 분리해 꼭 필요한 메서드만 이용할 수 있게 한다.

**의존관계 역전 원칙 (Dependency inversion principle)**
구체적인 구현이 아니라 추상화에 의존할 것

클래스간 의존성을 낮춰 유지보수를 편하게 하기 위함

## 추상클래스와 인터페이스의 차이

| 구분        | **추상 클래스**                                    | **인터페이스**                                          |
| --------- | --------------------------------------------- | -------------------------------------------------- |
| **목적**    | 공통 기능 제공 (상속)                                 | 규칙(계약) 정의 (구현 강제)                                  |
| **키워드**   | `abstract class`                              | `interface`                                        |
| **상속/구현** | 단일 상속만 가능                                     | 다중 구현 가능                                           |
| **메서드**   | 추상 + 일반 메서드 둘 다 가능                            | 기본적으로 추상 메서드, Java 8 이후 `default`, `static` 메서드 허용 |
| **변수**    | 일반 변수 선언 가능                                   | `public static final` 상수만 선언 가능                    |
| **생성자**   | 있음 (생성자 호출 가능)                                | 없음                                                 |
| **용도**    | 유사한 객체들의 기본 기능 제공                             | 서로 다른 클래스 간 **기능 통일** 목적                           |

## JVM 실행 과정

1. 프로그램 실행
2. OS로 부터 메모리 할당
3. 개발자 코드 작성
4. javac가 바이트 코드 .class로 변환
5. class loader가 jvm에 로딩
6. execution engine을 통해 해석
7. 해석된 바이트코드가 runtime data area에 배치되어 실질적인 수행이 이루어짐

## 자바 메모리 구조

**Method Area**
- JVM이 실행되면서 생기는 공간이다.
- Class 정보, 전역변수 정보, Static 변수 정보가 저장되는 공간이다.
- Runtime Constant Pool 에는 말 그대로 '상수' 정보가 저장되는 공간이다.
- 모든 스레드에서 정보가 공유된다.

**Heap**
- new 연산자로 생성된 객체, Array와 같은 동적으로 생성된 데이터가 저장되는 공간
- Heap에 저장된 데이터는 Garbage Collector 가 처리하지 않는한 소멸되지 않는다.
- Reference Type 의 데이터가 저장되는 공간
- 모든 스레드에서 정보가 공유된다.

**Stack**
- 지역변수, 메소드의 매개변수와 같이 잠시 사용되고 필요가 없어지는 데이터가 저장되는 공간
- Last In First Out, 나중에 들어온 데이터가 먼저 나간다
- 만약, 지역변수 이지만 Reference Type일 경우에는 Heap 에 저장된 데이터의 주소값을 Stack 에 저장해서 사용하게 된다.
- 스레드마다 하나씩 존재한다.

**PC Register**
- 스레드가 생성되면서 생기는 공간
- 스레드가 어느 명령어를 처리하고 있는지 그 주소를 등록한다.
- JVM이 실행하고 있는 현재 위치를 저장하는 역할

**Native Method Stack**
- Java 가 아닌 다른 언어 (C, C++) 로 구성된 메소드를 실행이 필요할 때 사용되는 공간

## 가비지 컬렉션

유효하지 않은 메모리인 가비지(Garbage)가 발생하는데 이를 알아서 정리해주는 것이 가비지 콜렉터이다.

## 컬렉션 프레임워크

배열을 사용하다 보면 여러가지 비효율적인 문제가 생긴다.

가장 큰 문제점은 크기가 고정적이라는 것이다.

배열의 크기는 생성할 때 결정되며 그 크기를 넘어가게 되면 더이상 데이터를 저장할 수 없다.

또 데이터를 삭제하면 해당 인덱스의 데이터는 비어있어 메모리가 낭비되는 등 여러 문제점들이 발생한다.

그렇기에 자바는 배열의 이러한 문제점을 해결하기 위해, **널리 알려져 있는 자료구조를 바탕으로 객체나 데이터들을 효율적으로 관리(추가, 삭제, 검색, 저장)할 수 있는 자료구조들을 만들어 놓았다. 이러한 자료구조들이 있는 라이브러리를 컬렉션 프레임워크라고 한다.**

대표적으로는 List, Set, Map, Stack, Queue 등이 있다.

## Servlet

자바 플랫폼에서 웹, 앱을 개발할 때 사용하는 기술.

코드 안에 HTML 태그가 삽입된다.

유지보수 측면에서 굉장히 비효율적이기 때문에 대부분 사용하지 않는다.

## JSP

서블릿과 반대로 HTML 내에 자바 코드를 삽입해 개발하는 형식.

서블릿과 마찬가지로 비효율적이다.

## 지역변수, 정적변수와 전역변수

**지역변수**
중괄호 {} 내에서만 작동하는 변수

**전역변수**
클래스 내에 위치하기 때문에 전체 영역에서 사용이 가능한 변수이며 new로 초기화 시킬 수 있다.

**정적변수**
static 프로그램 시작과 동시에 메모리에 올라간다.

프로그램 종료 전까지 메모리에 위치한다.

## 접근제어자 종류

**public**
public이 붙은 변수나 메서드는 <u>같은 프로젝트 안에서 사용 가능하다.</u>

**default**
접근 제어자가 아무것도 붙지 않은 변수나 메서드는 default 상태로, <u>같은 패키지 안에서만 사용 가능하다.</u>

**protected**
protected가 붙은 변수나 메서드는 다른 패키지에서는 사용이 불가능하다. 다만, 상속 관계일 때는 다른 클래스에서 사용 가능하다.

**private**
private이 붙은 변수나 메서드는 같은 클래스 내에서만 사용 가능하다.

## 접근 제어자를 사용하는 이유

보안 때문이라고 할 수 있다.

만약에 웹사이트에서 아이디와 비밀번호 같은 중요한 정보를 public 변수에 저장을 한다면 아무데서나 직접적으로 접근하여 그 값을 변경할 수 있기 때문에 노출되기 쉽다.

이런 중요한 변수들은 대부분 private를 붙여준다.

또한, 여러 사람들과 함께 프로그램을 만들다 보면 다른 사람이 내가 만든 중요한 변수나 메서드를 무분별하게 사용하여 값을 변경할 수 있는데, 이를 막기 위해 상황에 맞는 접근 제어자를 사용한다.

## Wrapper Class

<u>기본 자료타입(primitive type)을 객체로 다루기 위해서 사용하는 클래스</u>들을 래퍼 클래스(wrapper class)라고 한다.

자바는 모든 기본타입(primitive type)은 값을 갖는 객체를 생성할 수 있다.

이런 객체를 포장 객체라고도 하는데 그 이유는 기본 타입의 값을 내부에 두고 포장하기 때문이다.

래퍼 클래스로 감싸고 있는 기본 타입 값은 외부에서 변경할 수 없다.

만약 값을 변경하고 싶다면 새로운 포장 객체를 만들어야 한다.

## String '==' 비교 시 true가 나오는 이유

== 연산자와 String 클래스의 equals() 메소드의 가장 큰 차이점은 == 연산자는 비교하고자 하는 두개의 대상의 주소값을 비교하고, String클래스의 equals() 메소드는 비교하고자 하는 두개의 대상의 값 자체를 비교한다.

String == 비교 시 true가 나오는 이유는, String Pool (상수 풀) 때문이다.

자바에서 "hello"처럼 쌍따옴표로 지정된 문자열 리터럴은 JVM이 Heap이 아닌 특별한 영역인 "String Constant Pool"에 저장해, <u>똑같은 문자열 리터럴이 두 번 나오면 JVM은 같은 주소를 공유하게 한다.</u>

즉, a와 b는 같은 메모리 주소를 참조하게 되기 때문에 true를 반환한다.

<hr>

**참고**

- [참고자료 1](https://velog.io/@youngjun_10/BackEnd-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC#%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80)
- [참고자료 2](https://velog.io/@tjddnths0223/%EB%A9%B4%EC%A0%91-Spring-%EB%B0%8F-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%A7%88%EB%AC%B8%EB%A6%AC%EC%8A%A4%ED%8A%B8)
- [참고자료 3](https://velog.io/@kkyes1210/CS-%EC%A0%95%EB%A6%AC-%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B3%B5%ED%86%B5)
- [참고자료 4](https://velog.io/@superscman/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91%EC%A4%80%EB%B9%84-4%ED%83%84)
- [참고자료 5](https://velog.io/@tnscjs01/%EC%8B%A0%EC%9E%85-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC-%EC%9E%90%EB%B0%94-%EC%9B%B9-%EA%B0%9C%EB%B0%9C)